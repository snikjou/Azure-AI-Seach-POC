<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Azure AI Search -MTA</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
  />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <style>
    body { padding: 1rem; }
    pre { background: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: .5rem; max-height: 60vh; overflow:auto; }
    .monospace { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .caption { font-style: italic; opacity: .9; }
    .kv label { font-size: .9rem; color: #475569; }
  </style>
</head>
<body>
  <h1 class="h3 mb-3">Azure AI Search ‚Äî Metropolitan Transportation Authority (MTA)</h1>

  <form id="searchForm" class="row g-3">
    <!-- Endpoint and API key fields removed - now handled server-side -->
    <div class="col-12 col-md-8">
      <label class="form-label">search</label>
      <input type="text" class="form-control monospace" id="q" placeholder="e.g., 15-68-0267" value="15-68-0267" />
    </div>

    <div class="col-6 col-md-2">
      <label class="form-label">top</label>
      <input type="number" class="form-control" id="top" value="10" />
    </div>

    <div class="col-6 col-md-3">
      <label class="form-label">queryType</label>
      <select id="queryType" class="form-select">
        <option value="semantic" selected>semantic</option>
        <option value="simple">simple</option>
        <option value="full">full</option>
      </select>
    </div>

    <div class="col-12">
      <div class="form-check">
        <input class="form-check-input" type="checkbox" id="useVector" checked />
        <label class="form-check-label" for="useVector">Include vectorQueries (text-to-vector)</label>
      </div>
    </div>

    <div class="col-12">
      <button class="btn btn-primary" type="submit">Search</button>
      <button class="btn btn-outline-secondary" type="button" id="nextBtn" disabled>Next page ‚ñ∂</button>
      <span id="status" class="ms-3 text-muted"></span>
      <button class="btn btn-outline-info btn-sm ms-2" type="button" data-bs-toggle="collapse" data-bs-target="#scoreInfo" aria-expanded="false" aria-controls="scoreInfo">
        ‚ÑπÔ∏è Score Info
      </button>
    </div>
    <div class="col-12">
      <div class="collapse" id="scoreInfo">
        <div class="card card-body">
          <div class="mb-2">
            <span class="fw-bold">üîπ score</span>
            <div class="small">
              <strong>What it is:</strong> A relevance score computed by the search engine's full-text ranking algorithm (based on BM25).<br>
              <strong>Purpose:</strong> Indicates how well a document matches the search query based on term frequency, inverse document frequency, and field weights.<br>
              <strong>Scale:</strong> Relative and not normalized. A higher score means higher relevance.
            </div>
          </div>
          <div>
            <span class="fw-bold">üîπ rerankerScore</span>
            <div class="small">
              <strong>What it is:</strong> A semantic relevance score generated by the semantic reranker (if enabled).<br>
              <strong>Purpose:</strong> Uses deep learning models to assess semantic similarity between the query and the document.<br>
              <strong>Scale:</strong> Normalized between 0 and 4 | 4.0 = perfect semantic match | 0.0 = no semantic relevance
            </div>
          </div>
        </div>
      </div>
    </div>
  </form>

  <hr class="my-4"/>

  <div class="row">
    <div class="col-12 col-lg-6">
      <h2 class="h5">PDF Files Found in the Query response</h2>
      <div id="pdfList" class="border rounded p-2" style="max-height: 300px; overflow-y: auto;">
        <div class="text-muted">(PDF files will appear here)</div>
        
      </div>
    </div>
    <div class="col-12 col-lg-6">
      <h2 class="h5">Search Summary</h2>
      <div id="summary"></div>
    </div>
  </div>

  <script>
    const form = document.getElementById('searchForm');
    const nextBtn = document.getElementById('nextBtn');
    const summaryEl = document.getElementById('summary');
    const statusEl = document.getElementById('status');
    const pdfListEl = document.getElementById('pdfList');

    let lastResponse = null;
    let storageAccountUrl = '';

    // Load configuration from server
    async function loadConfig() {
      try {
        const response = await fetch('/api/config');
        const config = await response.json();
        storageAccountUrl = config.storageAccountUrl || '';
      } catch (error) {
        console.error('Failed to load configuration:', error);
      }
    }

    // Load config when page loads
    loadConfig();

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      nextBtn.disabled = true;
      summaryEl.innerHTML = '';
      pdfListEl.innerHTML = '<div class="text-muted">Loading...</div>';
      statusEl.textContent = 'Sending request‚Ä¶';

      const body = buildRequestBodyFromForm();
      await runSearch(body);
    });

    nextBtn.addEventListener('click', async () => {
      if (!lastResponse || !lastResponse['@search.nextPageParameters']) return;
      const body = lastResponse['@search.nextPageParameters'];
      statusEl.textContent = 'Paging‚Ä¶';
      await runSearch(body);
    });

    function getApiVersion() {
      // Since we're using a proxy, return a preview version that supports aiServicesVision vectorizer
      return '2024-11-01-preview';
    }

    function supportsTextVectorQueries(apiVersion) {
      // crude: any 2024+ preview or 2024+ GA version
      return /2024-/.test(apiVersion);
    }

    function buildRequestBodyFromForm() {
      const q = document.getElementById('q').value || '';
      const top = parseInt(document.getElementById('top').value || '50', 10);
      const skip = 0; // Fixed value, removed from UI
      const queryType = document.getElementById('queryType').value;
      const captions = 'extractive'; // Fixed value, removed from UI
      const answers = 'extractive|count-3'; // Fixed value, removed from UI
      const queryLanguage = 'en-us'; // Fixed value, removed from UI
      const queryRewrites = 'generative'; // Fixed value, removed from UI
      const useVector = document.getElementById('useVector').checked;

      const body = {
        search: q,
        count: true,
        top,
        skip,
        queryType,
        queryLanguage,
      };

      if (queryType === 'semantic' && captions && captions !== 'none') body.captions = captions;
      if (queryType === 'semantic' && answers && answers !== 'none') body.answers = answers;
      if (queryRewrites && queryRewrites !== 'none') body.queryRewrites = queryRewrites;

      // Only include vectorQueries:text when API supports it
      const apiVersion = getApiVersion();
      if (useVector && supportsTextVectorQueries(apiVersion)) {
        body.vectorQueries = [{
          kind: "text",
          fields: "content_embedding",
          text: q
        }];
      }
      // Else: omit vectorQueries to avoid 400 on 2023-11-01

      return body;
    }

    async function runSearch(body) {
      try {
        // Use the proxy server instead of direct API calls
        let res = await fetch('/api/search', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        if (res.status === 400) {
          const clone = await res.clone().json().catch(() => null);
          const msg = clone?.error?.message || '';

          // Strip queryLanguage if rejected
          if (/queryLanguage/i.test(msg)) {
            const b2 = { ...body };
            delete b2.queryLanguage;
            res = await fetch('/api/search', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(b2)
            });
          }

          // If still 400 and queryRewrites is the problem, strip it too
          if (res.status === 400) {
            const clone2 = await res.clone().json().catch(() => null);
            const msg2 = clone2?.error?.message || '';
            if (/queryRewrites/i.test(msg2)) {
              const b3 = { ...body };
              delete b3.queryLanguage;
              delete b3.queryRewrites;
              res = await fetch('/api/search', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(b3)
              });
            }
          }
        }

        const json = await res.json();
        lastResponse = json;
        
        renderSummary(json);
        renderPdfList(json);
        statusEl.textContent = `HTTP ${res.status} ‚Ä¢ ${new Date().toLocaleTimeString()}`;
        nextBtn.disabled = !json['@search.nextPageParameters'];
      } catch (err) {
        summaryEl.innerHTML = '';
        pdfListEl.innerHTML = '<div class="text-muted">Error loading results</div>';
        statusEl.textContent = 'Error';
        nextBtn.disabled = true;
      }
    }

    function renderSummary(json) {
      const count = json['@odata.count'];
      const answers = json['@search.answers'] || [];
      const values = json.value || [];
      const next = !!json['@search.nextPageParameters'];

      const frag = document.createDocumentFragment();

      const meta = document.createElement('div');
      meta.className = 'kv mb-3';
      meta.innerHTML = `
        <div><label>Total count:</label> <strong>${count ?? '‚Äî'}</strong></div>
        <div><label>Answers:</label> <strong>${answers.length}</strong></div>
        <div><label>Has next page:</label> <strong>${next ? 'Yes' : 'No'}</strong></div>
      `;
      frag.appendChild(meta);

      const list = document.createElement('div');
      values.forEach((v, i) => {
        const title = v.document_title || v.id || v.content_id || '(no title)';
        const cap = (v['@search.captions'] && v['@search.captions'][0]?.text) || '';
        const bm25 = v['@search.score'];
        const rerank = v['@search.rerankerScore'];

        // Generate clickable link for PDF documents if storageAccountUrl is available
        let titleHtml = '';
        if (storageAccountUrl && title.toLowerCase().includes('.pdf')) {
          const baseUrl = storageAccountUrl.endsWith('/') ? storageAccountUrl : storageAccountUrl + '/';
          const fileUrl = baseUrl + encodeURIComponent(title);
          titleHtml = `<strong>${i + 1}. <a href="${escapeHtml(fileUrl)}" target="_blank" rel="noopener noreferrer" style="color: #0066cc; text-decoration: underline;">${escapeHtml(title)}</a></strong>`;
        } else {
          titleHtml = `<strong>${i + 1}. ${escapeHtml(title)}</strong>`;
        }

        const card = document.createElement('div');
        card.className = 'border rounded p-2 mb-2';
        card.innerHTML = `
          <div>${titleHtml}</div>
          <div class="small text-muted monospace">score=${bm25 ?? '‚Äî'} ‚Ä¢ reranker=${rerank ?? '‚Äî'}</div>
          ${cap ? `<div class="caption mt-1">${escapeHtml(cap)}</div>` : ''}
        `;
        list.appendChild(card);
      });

      frag.appendChild(list);
      summaryEl.innerHTML = '';
      summaryEl.appendChild(frag);
    }

    function renderPdfList(json) {
      const values = json.value || [];
      const pdfFiles = new Map(); // Map to store filename -> item.filename mapping
      
      // Extract PDF file names, prioritizing item.filename
      values.forEach(item => {
        // First, check if item.filename exists and is a PDF
        if (item.filename && typeof item.filename === 'string' && 
            item.filename.toLowerCase().includes('.pdf')) {
          const filename = item.filename.split('/').pop().split('\\').pop();
          // Store the original item.filename for URL construction
          pdfFiles.set(filename, item.filename);
        } else {
          // Fallback: Check other common fields that might contain PDF file names
          const possibleFields = [
            item.document_title,
            item.title,
            item.source,
            item.file_name,
            item.document_name,
            item.name,
            item.id
          ];
          
          for (const field of possibleFields) {
            if (field && typeof field === 'string') {
              // Check if the field contains .pdf or looks like a PDF filename
              if (field.toLowerCase().includes('.pdf') || 
                  field.toLowerCase().endsWith('.pdf') ||
                  (field.toLowerCase().includes('pdf') && field.includes('.'))) {
                // Extract just the filename if it's a full path
                const filename = field.split('/').pop().split('\\').pop();
                if (filename.toLowerCase().includes('.pdf')) {
                  // Store with the field value as the path
                  if (!pdfFiles.has(filename)) {
                    pdfFiles.set(filename, field);
                  }
                  break;
                }
              }
            }
          }
        }
      });

      // Render the PDF list
      const frag = document.createDocumentFragment();
      
      if (pdfFiles.size === 0) {
        const noFiles = document.createElement('div');
        noFiles.className = 'text-muted';
        noFiles.textContent = 'No PDF files found in results';
        frag.appendChild(noFiles);
      } else {
        const count = document.createElement('div');
        count.className = 'mb-2 fw-bold';
        count.textContent = `Found ${pdfFiles.size} unique PDF file(s):`;
        frag.appendChild(count);

        Array.from(pdfFiles.keys()).sort().forEach(displayName => {
          const itemPath = pdfFiles.get(displayName);
          const item = document.createElement('div');
          item.className = 'border-bottom py-1 small';
          
          // Generate the Azure Storage URL if storageAccountUrl is configured
          if (storageAccountUrl) {
            // Ensure the storage URL ends with a slash
            const baseUrl = storageAccountUrl.endsWith('/') ? storageAccountUrl : storageAccountUrl + '/';
            // Use the original item.filename (itemPath) for the URL
            const fileUrl = baseUrl + encodeURIComponent(itemPath);
            item.innerHTML = `üìÑ <a href="${escapeHtml(fileUrl)}" target="_blank" rel="noopener noreferrer">${escapeHtml(displayName)}</a>`;
          } else {
            // If no storage URL configured, just show the filename
            item.innerHTML = `üìÑ ${escapeHtml(displayName)}`;
          }
          
          frag.appendChild(item);
        });
      }
      
      pdfListEl.innerHTML = '';
      pdfListEl.appendChild(frag);
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }
  </script>
</body>
</html>
